# 01 课程介绍

[自定义工具函数库 | 尚硅谷](https://zxfjd3g.github.io/atguigu_utils-docs/)

克隆对象涉及一个问题 深拷贝 课程会讲解四种深拷贝的方式

大厂面试喜欢一些底层的 原生JS 所以这门课程对面试是有帮助的

​	

# 02 call函数封装实现

可以改变函数运行时的this值 并且得到函数运行的执行结果

![image-20221026103416179](自定义工具函数库.assets/image-20221026103416179.png)

第一次打印的时候 obj的temp属性还没有被delete 所以可以看到temp属性被打印出来 执行完call函数后 temp属性被delete 所以就看不到了

**01-call.js**

```js
/**
 * 第一个参数 我们要执行的函数
 * 第二个参数 函数运行时this指向的对象
 * 第三个参数起 函数运行时的参数
 */
function call(Fn,obj,...args){
  // 判断
  if(obj === undefined || obj === null){
    obj = globalThis; //全局对象 globalThis es11的特性 用它来指向全局对象
  }
  // 为 obj 添加临时方法
  obj.temp = Fn;
  // 调用 temp 方法
  let result = obj.temp(...args);
  // 删除 temp 方法
  delete obj.temp;
  // 返回执行结果
  return result;
}
```

**01-call.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="01-call.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      return a + b + this.c
    }
    // 声明一个对象
    let obj = {
      c:521
    }
    // 添加全局属性
    window.c = 1314;

    // 执行 call 函数
    console.log(call(add,obj,10,20));
    // console.log(obj);
    console.log(call(add,null,10,20));
    // console.log(obj);

  </script>
</body>
</html>
```

​	

# 03 apply函数封装实现

也是改变函数运行时的this值 并且得到函数运行的执行结果

但apply函数和call函数还是有一个很明显的区别 区别在于函数运行时的一个参数 它的设定是一个数组 而call的实参是以单独形式存在的

**02-apply.js**

```js
// 这里就不用res参数了（... 表示多个参数吗？查一下） 直接用args普通参数就可以了
function apply(Fn, obj, args){ // 因为这里args只传一个数组参数 所以写一个args就行
  //判断
  if(obj === undefined || obj === null){ // 如果对象是未定义或为空
    obj = globalThis; //让对象等于全局对象（chrome里全局对象是window对象 IE里的全局对象是global对象）
  }
  // 为 obj 添加临时方法
  obj.temp = Fn;
  // 执行方法
  let result = obj.temp(...args); // ...是扩展运算符 要把它（数组）展开
  // 删除临时属性
  delete obj.temp;
  // 返回结果
  return result;
}
```

**02-apply.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>apply 测试</title>
  <script src="02-apply.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      return a + b + this.c
    }
    // 声明一个对象
    let obj = {
      c:521
    }
    // 添加全局属性
    window.c = 1314;

    // 执行 apply 函数
    console.log(apply(add,obj,[10, 20]));
    console.log(apply(add,null,[10, 20]));
  </script>
</body>
</html>
```

​	

# 04 bind函数封装实现

bind函数跟call函数很像 call会执行目标函数 bind会创建一个新函数 但是它不会去执行函数 这是bind和call的一个区别 至于参数这块他们是相同的

![image-20221026204406292](自定义工具函数库.assets/image-20221026204406292.png)

![image-20221026204851270](自定义工具函数库.assets/image-20221026204851270.png)

**03-bind.js**

```js
function bind(Fn, obj, ...args){
  // 返回一个新的函数
  return function(...args2){
    // 执行 call 函数
    return call(Fn, obj, ...args, ...args2); //这里的...args, ...args2不代表什么 就是实参传入的【位置以及调用】顺序而已
  }
}
```

**03-bind.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>bind函数</title>
  <script src="01-call.js"></script>
  <script src="03-bind.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      console.log(arguments);
      return a + b + this.c;
    }
    //声明一个对象
    let obj = {
      c: 521
    };
    //添加全局属性
    window.c = 1314;

    //执行函数
    // let fn = bind(add, obj, 10, 20);
    // console.log(fn());

    // let fn2 = bind(add, obj);
    // console.log(fn2(10,20));

    let fn3 = add.bind(obj,10,20); //这里的bind不是我们自定义的 而是原型内置的
    console.log(fn3(30, 40));

    let fn4 = bind(add, obj, 10, 20);
    console.log(fn4(30, 40)); //后面的失效只是因为add只调用到了前面的两个实参 后面的没调用就没参与计算 可以通过arguments看到实参的数量和顺序位置
  </script>
</body>
</html>
```

​	

# 05 函数节流

函数节流与防抖在做什么事情呢？其实是在控制事件处理程序的执行频率

为什么要控制事件回调的执行频率呢？是因为浏览器当中有一些事件 比如说这个onresize事件就是窗口的变化事件还有mousemove鼠标移动事件当然还有这个scroll事件窗口滚动事件 这些事件它的触发频率非常高 极有可能会造成页面卡顿 如果说在这个事件处理程序当中 还包含了与后端的交互 这样还会给后端增加很多压力 所以这个时候函数的节流与防抖控制频率就显得非常重要了

![image-20221027090448596](自定义工具函数库.assets/image-20221027090448596.png)

**04-throttle.js**

```js
// 第一个参数是回调 第二个参数是等待间隔
function throttle(callback, wait){
  // 定义开始时间
  let start = 0;
  // 返回结果是一个函数
  return function(e){
    // console.log('iloveyou');
    // 获取当前的时间戳
    let now = Date.now();
    // 判断
    if(now - start >= wait){
      // 若满足条件 则执行回调函数
      callback.call(this, e);
      // 修改开始时间
      start = now;
    }
  }
}
```

**04-throttle.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>节流测试</title>
  <script src="04-throttle.js"></script>
  <!-- <script src="throttle.js"></script> -->
  <style>
    body{
      height: 2000px;
      background: linear-gradient(#125,#eae);
    }
  </style>
</head>
<body>
  <script>
    //绑定滚动事件
    // window.addEventListener('scroll',function(){
    //   console.log(Data.now());
    // })

    window.addEventListener('scroll',throttle(function(e){
      // console.log(Date.now());
      // console.log(this);
      console.log(e);
    },500));
  </script>
</body>
</html>
```

![image-20221027131758249](自定义工具函数库.assets/image-20221027131758249.png)

​	

# 06 函数防抖

当事件触发之后 它不会立即执行回调 会等待一段时间再去执行回调 那么在等待的时间过程呢 如果你再次触发了事件 它会再次等待 上一个事件处理程序是不执行的 直到一次触发等待超过时间间隔 才进行回调

![image-20221027102019626](自定义工具函数库.assets/image-20221027102019626.png)

setTimeout有个特点是它内部的this指向外层作用下this的值

this指向事件源

![image-20221027103900670](自定义工具函数库.assets/image-20221027103900670.png)

如果不是函数的话 这个事件在触发之后没法去执行回调

**【顶级理解】**![image-20221027104217669](自定义工具函数库.assets/image-20221027104217669.png)

而且返回的函数这里还要加事件回调（事件对象）因为这玩意 人家内部要用 往里边传入参数 如果你没有形参去接 到时候你在代码题里边没用办法获取事件对象![image-20221027104458846](自定义工具函数库.assets/image-20221027104458846.png)

![image-20221027105433560](自定义工具函数库.assets/image-20221027105433560.png)

![图A](自定义工具函数库.assets/image-20221027105525103.png)

if判断和setTimeout里的清空都不能省 因为一个是执行完的清空 一个是未执行的清空

我们要的效果是多A次定时器time内打入的话 只执行最后一个定时器的

图A框里的 ` timeId = null` 如果没有写的话 效果已经是能达成 但是有小瑕疵 逻辑不严谨 执行了些无用代码 就是每一次都要进入if判断语句去清空（如果定时器有执行完的话（也就是超过了time时间后才执行任务））它的清空是没用的 因为上个定时器已经执行完失效了 所以这是浪费性能的 所以有执行定时器的话 正确方式是 顺便在最后补一个 `timeId = null` 重置定时器变量 当我们在上一次执行成功 执行回调之后应该要将这个定时器变量给它复原 以此来优化性能 更为合理一些

通过这样的事件就可以很好的控制这个事件的触发频率 特别是这种相关关键字搜索的功能 它与服务器是直接挂钩的 你这里输什么就会传递给服务器什么 如果你触发频率不控制 他就会向服务器发送大量请求 给服务器造成压力 这是我们当前对防抖做的一个实现

**05-debounce.js**

```js
function debounce(callback, time){
  // 定时器变量
  let timeId  = null;
  // 返回一个函数
  return function(e){
    // 判断
    if(timeId !== null){
      // 清空定时器
      clearTimeout(timeId);
    }
    // 启动定时器
    timeId = setTimeout(() => {
      // 执行回调
      callback.call(this, e);
      // 重置定时器
      timeId = null;
    }, time);
  }
}
```

**05-debounce.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>防抖测试</title>
  <script src="05-debounce.js"></script>
</head>
<body>
  <input type="text">
  <script>
    let input = document.querySelector('input');

    // 当键盘按下时 会有对应的keyCode返回
    // 这里自己理解错了一点 太久没看js给忘了 以为是函数的返回结果返回给onkeydown 实际上onkeydown才是这个函数的函数名 所以按下键盘时便是执行函数 自然就会在控制台打印结果
    // input.onkeydown = function(e){
    //   console.log(e.keyCode);
    // }

    input.onkeydown = debounce(function(e){
      console.log(e.keyCode);
    },1000);
  </script>
</body>
</html>
```

​	

# 07 数组函数map封装实现

