# 01 课程介绍

[自定义工具函数库 | 尚硅谷](https://zxfjd3g.github.io/atguigu_utils-docs/)

克隆对象涉及一个问题 深拷贝 课程会讲解四种深拷贝的方式

大厂面试喜欢一些底层的 原生JS 所以这门课程对面试是有帮助的

​	

# 02 call函数封装实现

可以改变函数运行时的this值 并且得到函数运行的执行结果

![image-20221026103416179](自定义工具函数库.assets/image-20221026103416179.png)

第一次打印的时候 obj的temp属性还没有被delete 所以可以看到temp属性被打印出来 执行完call函数后 temp属性被delete 所以就看不到了

**01-call.js**

```js
/**
 * 第一个参数 我们要执行的函数
 * 第二个参数 函数运行时this指向的对象
 * 第三个参数起 函数运行时的参数
 */
function call(Fn,obj,...args){
  // 判断
  if(obj === undefined || obj === null){
    obj = globalThis; //全局对象 globalThis es11的特性 用它来指向全局对象
  }
  // 为 obj 添加临时方法
  obj.temp = Fn;
  // 调用 temp 方法
  let result = obj.temp(...args);
  // 删除 temp 方法
  delete obj.temp;
  // 返回执行结果
  return result;
}
```

**01-call.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="01-call.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      return a + b + this.c
    }
    // 声明一个对象
    let obj = {
      c:521
    }
    // 添加全局属性
    window.c = 1314;

    // 执行 call 函数
    console.log(call(add,obj,10,20));
    // console.log(obj);
    console.log(call(add,null,10,20));
    // console.log(obj);

  </script>
</body>
</html>
```

​	

# 03 apply函数封装实现

也是改变函数运行时的this值 并且得到函数运行的执行结果

但apply函数和call函数还是有一个很明显的区别 区别在于函数运行时的一个参数 它的设定是一个数组 而call的实参是以单独形式存在的

**02-apply.js**

```js
// 这里就不用res参数了（... 表示多个参数吗？查一下） 直接用args普通参数就可以了
function apply(Fn, obj, args){ // 因为这里args只传一个数组参数 所以写一个args就行
  //判断
  if(obj === undefined || obj === null){ // 如果对象是未定义或为空
    obj = globalThis; //让对象等于全局对象（chrome里全局对象是window对象 IE里的全局对象是global对象）
  }
  // 为 obj 添加临时方法
  obj.temp = Fn;
  // 执行方法
  let result = obj.temp(...args); // ...是扩展运算符 要把它（数组）展开
  // 删除临时属性
  delete obj.temp;
  // 返回结果
  return result;
}
```

**02-apply.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>apply 测试</title>
  <script src="02-apply.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      return a + b + this.c
    }
    // 声明一个对象
    let obj = {
      c:521
    }
    // 添加全局属性
    window.c = 1314;

    // 执行 apply 函数
    console.log(apply(add,obj,[10, 20]));
    console.log(apply(add,null,[10, 20]));
  </script>
</body>
</html>
```

​	

# 04 bind函数封装实现

bind函数跟call函数很像 call会执行目标函数 bind会创建一个新函数 但是它不会去执行函数 这是bind和call的一个区别 至于参数这块他们是相同的

![image-20221026204406292](自定义工具函数库.assets/image-20221026204406292.png)

![image-20221026204851270](自定义工具函数库.assets/image-20221026204851270.png)

**03-bind.js**

```js
function bind(Fn, obj, ...args){
  // 返回一个新的函数
  return function(...args2){
    // 执行 call 函数
    return call(Fn, obj, ...args, ...args2); //这里的...args, ...args2不代表什么 就是实参传入的【位置以及调用】顺序而已
  }
}
```

**03-bind.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>bind函数</title>
  <script src="01-call.js"></script>
  <script src="03-bind.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      console.log(arguments);
      return a + b + this.c;
    }
    //声明一个对象
    let obj = {
      c: 521
    };
    //添加全局属性
    window.c = 1314;

    //执行函数
    // let fn = bind(add, obj, 10, 20);
    // console.log(fn());

    // let fn2 = bind(add, obj);
    // console.log(fn2(10,20));

    let fn3 = add.bind(obj,10,20); //这里的bind不是我们自定义的 而是原型内置的
    console.log(fn3(30, 40));

    let fn4 = bind(add, obj, 10, 20);
    console.log(fn4(30, 40)); //后面的失效只是因为add只调用到了前面的两个实参 后面的没调用就没参与计算 可以通过arguments看到实参的数量和顺序位置
  </script>
</body>
</html>
```

​	

# 05 函数节流

函数节流与防抖在做什么事情呢？其实是在控制事件处理程序的执行频率

为什么要控制事件回调的执行频率呢？是因为浏览器当中有一些事件 比如说这个onresize事件就是窗口的变化事件还有mousemove鼠标移动事件当然还有这个scroll事件窗口滚动事件 这些事件它的触发频率非常高 极有可能会造成页面卡顿 如果说在这个事件处理程序当中 还包含了与后端的交互 这样还会给后端增加很多压力 所以这个时候函数的节流与防抖控制频率就显得非常重要了

![image-20221027090448596](自定义工具函数库.assets/image-20221027090448596.png)

**04-throttle.js**

```js
// 第一个参数是回调 第二个参数是等待间隔
function throttle(callback, wait){
  // 定义开始时间
  let start = 0;
  // 返回结果是一个函数
  return function(e){
    // console.log('iloveyou');
    // 获取当前的时间戳
    let now = Date.now();
    // 判断
    if(now - start >= wait){
      // 若满足条件 则执行回调函数
      callback.call(this, e);
      // 修改开始时间
      start = now;
    }
  }
}
```

**04-throttle.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>节流测试</title>
  <script src="04-throttle.js"></script>
  <!-- <script src="throttle.js"></script> -->
  <style>
    body{
      height: 2000px;
      background: linear-gradient(#125,#eae);
    }
  </style>
</head>
<body>
  <script>
    //绑定滚动事件
    // window.addEventListener('scroll',function(){
    //   console.log(Data.now());
    // })

    window.addEventListener('scroll',throttle(function(e){
      // console.log(Date.now());
      // console.log(this);
      console.log(e);
    },500));
  </script>
</body>
</html>
```

![image-20221027131758249](自定义工具函数库.assets/image-20221027131758249.png)

​	

# 06 函数防抖

当事件触发之后 它不会立即执行回调 会等待一段时间再去执行回调 那么在等待的时间过程呢 如果你再次触发了事件 它会再次等待 上一个事件处理程序是不执行的 直到一次触发等待超过时间间隔 才进行回调

![image-20221027102019626](自定义工具函数库.assets/image-20221027102019626.png)

setTimeout有个特点是它内部的this指向外层作用下this的值

this指向事件源

![image-20221027103900670](自定义工具函数库.assets/image-20221027103900670.png)

如果不是函数的话 这个事件在触发之后没法去执行回调

**【顶级理解】**![image-20221027104217669](自定义工具函数库.assets/image-20221027104217669.png)

而且返回的函数这里还要加事件回调（事件对象）因为这玩意 人家内部要用 往里边传入参数 如果你没有形参去接 到时候你在代码题里边没用办法获取事件对象![image-20221027104458846](自定义工具函数库.assets/image-20221027104458846.png)

![image-20221027105433560](自定义工具函数库.assets/image-20221027105433560.png)

![图A](自定义工具函数库.assets/image-20221027105525103.png)

if判断和setTimeout里的清空都不能省 因为一个是执行完的清空 一个是未执行的清空

我们要的效果是多A次定时器time内打入的话 只执行最后一个定时器的

图A框里的 ` timeId = null` 如果没有写的话 效果已经是能达成 但是有小瑕疵 逻辑不严谨 执行了些无用代码 就是每一次都要进入if判断语句去清空（如果定时器有执行完的话（也就是超过了time时间后才执行任务））它的清空是没用的 因为上个定时器已经执行完失效了 所以这是浪费性能的 所以有执行定时器的话 正确方式是 顺便在最后补一个 `timeId = null` 重置定时器变量 当我们在上一次执行成功 执行回调之后应该要将这个定时器变量给它复原 以此来优化性能 更为合理一些

通过这样的事件就可以很好的控制这个事件的触发频率 特别是这种相关关键字搜索的功能 它与服务器是直接挂钩的 你这里输什么就会传递给服务器什么 如果你触发频率不控制 他就会向服务器发送大量请求 给服务器造成压力 这是我们当前对防抖做的一个实现

**05-debounce.js**

```js
function debounce(callback, time){
  // 定时器变量
  let timeId  = null;
  // 返回一个函数
  return function(e){
    // 判断
    if(timeId !== null){
      // 清空定时器
      clearTimeout(timeId);
    }
    // 启动定时器
    timeId = setTimeout(() => {
      // 执行回调
      callback.call(this, e);
      // 重置定时器
      timeId = null;
    }, time);
  }
}
```

**05-debounce.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>防抖测试</title>
  <script src="05-debounce.js"></script>
</head>
<body>
  <input type="text">
  <script>
    let input = document.querySelector('input');

    // 当键盘按下时 会有对应的keyCode返回
    // 这里自己理解错了一点 太久没看js给忘了 以为是函数的返回结果返回给onkeydown 实际上onkeydown才是这个函数的函数名 所以按下键盘时便是执行函数 自然就会在控制台打印结果
    // input.onkeydown = function(e){
    //   console.log(e.keyCode);
    // }

    input.onkeydown = debounce(function(e){
      console.log(e.keyCode);
    },1000);
  </script>
</body>
</html>
```

​	

# 07 数组函数map封装实现

![image-20221028125253608](自定义工具函数库.assets/image-20221028125253608.png)

**01-map.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>数组API测试</title>
  <script src="01-declares.js"></script>
</head>
<body>
  <script>
    // 声明一个数组
    const arr = [1,2,3,4,5];

    const result = map(arr, (item, index) => {
      console.log(index);
      return item * 10;
    });

    console.log(result);
  </script>
</body>
</html>
```

**01-map.js**

```js
function map(arr, callback){
  // 声明一个空的数组
  let result = [];
  // 遍历数组
  for (var i = 0; i < arr.length; i++) {
     // 执行回调
     result.push(callback(arr[i], i));
  }
  // 返回结果
  return result;
}
```

​	

# 08 reduce函数封装

![image-20221028133633755](自定义工具函数库.assets/image-20221028133633755.png)

没有上一次计算的结果（也就是才第一次参与运算）就是给定的初始化+value 后面就都是result+value

**02-reduce.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数组API测试</title>
    <script src="02-reduce.js"></script>
  </head>
  <body>
    <script>
      // 声明一个数组
      const arr = [1, 2, 3, 4, 5];

      // 系统内置
      // reduce()有三个参数 第一个是数组 第二个是回调 第三个是初始值
      // let result = arr.reduce(function (res, value) {
      //   return res + value;
      // }, 0);

      // console.log(result);

      // 自定义
      let result = reduce(
        arr,
        function (res, value) {
          return res + value;
        },
        10
      );

      console.log(result);
    </script>
  </body>
</html>

```

**02-reduce.js**

```js
function reduce(arr, callback, initValue) {
  // 声明变量
  let result = initValue;
  // 执行回调
  for (var i = 0; i < arr.length; i++) {
    // 执行回调
    result = callback(result, arr[i]);
  }
  //返回最终的结果
  return result;
}
```

​	

# 09 filter函数封装

**03-filter.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数组API测试</title>
    <script src="03-filter.js"></script>
  </head>
  <body>
    <script>
      // 声明一个数组
      const arr = [1, 2, 3, 4, 5];

      // filter 内置
      // const result = arr.filter((item) => item % 2 === 1);

      // filter 自定义
      const result = arr.filter((item) => item % 2 === 0);
      console.log(result);
    </script>
  </body>
</html>

```

**03-filter.js**

```js
/**
 * 
 * @param {Array} arr 
 * @param {Function} callback 
 */
function filter(arr, callback) {
  // 声明空数组
  let result = [];
  // 遍历数组
  for (var i = 0; i < arr.length; i++) {
    // 执行回调
    let res = callback(arr[i], i);
    // 判断 如果为真则压入到 result 结果中
    if (res) {
      result.push(arr[i]);
    }
  }
  // 返回结果
  return result;
}
```

​	

# 10 find函数封装

**04-find.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数组API测试</title>
    <script src="04-find.js"></script>
  </head>
  <body>
    <script>
      // 声明一个数组
      const arr = [1, 2, 3, 4, 2050, 5, 1024];

      //find 内置
      // const result = arr.find((item) => {
      //   return item > 1000;
      // });

      const result = find(arr, (item, index) => item > 10000);
      console.log(result);
    </script>
  </body>
</html>

```

**04-find.js**

```js
/**
 * 
 * @param {Array} arr 
 * @param {Function} callback 
 */
function find(arr, callback) {
  // 遍历数组
  for (var i = 0; i < arr.length; i++) {
    // 执行回调
    let res = callback(arr[i], i);
    // 判断
    if (res) {
      // 返回当前正在遍历的元素
      return arr[i];
    }
  }
  // 如果没有遇到满足条件的 返回 undefined
  return undefined;
}
```

​	

# 11 findIndex函数封装

**05-findIndex.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数组API测试</title>
    <script src="05-findIndex.js"></script>
  </head>
  <body>
    <script>
      // 声明一个数组
      const arr = [1, 2, 3, 4, 2050, 5, 1024];

      // 内置
      // const result = arr.findIndex((item) => item > 1000);

      // 自定义
      const result = findIndex(arr, (item, index) => item > 10000);
      console.log(result);
    </script>
  </body>
</html>

```

**05-findIndex.js**

```js
/**
 * 
 * @param {Array} arr 
 * @param {Function} callback 
 */
function findIndex(arr, callback) {
  // 遍历数组
  for (var i = 0; i < arr.length; i++) {
    // 执行回调
    let res = callback(arr[i], i);
    // 判断
    if (res) {
      // 返回当前正在遍历的元素的下标
      return i;
    }
  }
  // 如果没有遇到满足条件的 返回 -1
  return -1;
}
```

​	

# 12 数组去重

**06-every和some.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="06-every和some.js"></script>
  </head>
  <body>
    <script>
      // 声明一个数组
      const arr = [1, 2, 3, 4, 2050, 5, 1024];

      // const result = arr.every((item) => item > 0);
      // const result = arr.some((item) => item > 20000);

      // const result = every(arr, (item, index) => {
      //   return item > 0;
      // });

      const result = some(arr, (item, index) => {
        return item < 0;
      });
      console.log(result);
    </script>
  </body>
</html>

```

**06-every和some.js**

```js
/**
 * 
 * @param {Array} arr 
 * @param {Function} callback 
 * @returns 
 */
function every(arr, callback) {
  // 遍历数组
  for (var i = 0; i < arr.length; i++) {
    // 执行回调 如果回调执行返回结果为 false
    if (!callback(arr[i], i)) {
      return false;
    }
  }
  // 如果都满足条件则返回 true
  return true;
}

function some(arr, callback) {
  // 遍历数组
  for (var i = 0; i < arr.length; i++) {
    // 执行回调 如果回调执行返回结果为 false
    if (callback(arr[i], i)) {
      return true;
    }
  }
  // 如果都满足条件则返回 true
  return false;
}
```

​	

# 13 数组去重-1

**07-数组去重.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>去重测试</title>
    <script src="07-unique.js"></script>
  </head>
  <body>
    <script>
      // 声明一个数组
      const arr = [1, 2, 3, 2, 1, 4, 5];

      //去重
      console.log(unique(arr));
    </script>
  </body>
</html>

```

**07-unique.js**

```js

function unique(arr) {
  // 声明一个空数组
  const result = [];
  // 遍历原始数组
  arr.forEach(item => {
    // 检测 result 数组中是否包含这个元素
    if (result.indexOf(item) === -1) {
      // 若没有该元素 则插入到result中
      result.push(item);
    }
  });
  // 返回
  return result;
}
```

​	

# 14 数组去重-2

**07-数组去重.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>去重测试</title>
    <script src="07-unique.js"></script>
  </head>
  <body>
    <script>
      // 声明一个数组
      const arr = [1, 2, 3, 2, 1, 4, 5, 6];

      //去重 方式一
      // console.log(unique(arr));

      //去重 方式二
      console.log(unique2(arr));
    </script>
  </body>
</html>
```

**07-unique.js**

```js
// 把item值当作对象属性进行存储
function unique2(arr) {
  // 声明一个空数组
  const result = [];
  // 声明空对象
  const obj = {};
  // 遍历数组
  arr.forEach(item => {
    if (obj[item] === undefined) {
      // 将 item 作为下标存储在 obj 中
      obj[item] = true;
      result.push(item);
    }
  });
  // 返回
  return result;
}

```

​	

# 15 数组去重-3

set集合和数组很像 但它里面的元素的唯一的

set实现了迭代器[iterator](javascript:;)的接口 所以可以使用…的方式展开

**07-数组去重.html**

```html
// 去重 方式三
      console.log(unique3(arr));
```

**07-数组去重.js**

```js
// 用es6语法 set去做去重
function unique3(arr) {
  // // 数组转化为集合 Set
  // let set = new Set(arr);
  // // 将 set 展开创建一个数组
  // let array = [...set];
  // return array;

  // 一步到位
  return [...new Set(arr)];
}
```

​	

# 16 concat数组合并

除了传递数组元素以外 还能传递非数组的元素

**08-数组合并与拆分.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数组合并与拆分</title>
    <script src="08-concat.js"></script>
  </head>
  <body>
    <script>
      let arr = [1, 2, 3];
      // const result = arr.concat([4, 5, 6], 7, 8); // 传递非数组元素 7，8 也能将其合并在一起

      const result = concat(arr, [4, 5, 6], 7, 8); // 传递非数组元素 7，8 也能将其合并在一起
      console.log(result);

      // const result = [...arr];
      // arr.forEach((item) => {
      //   // console.log(item);
      //   result.push(item);
      // });
      // console.log(result);
    </script>
  </body>
</html>

```

**08-concat.js**

```js
/**
 * 
 * @param {Array} arr 
 * @param  {...any} args 
 */
function concat(arr, ...args) {
  // 声明一个空数组
  const result = [...arr]; // 展开
  // const result = arr; // 这样也行
  // 遍历数组
  args.forEach(item => {
    // 判断 item 是否为数组
    if (Array.isArray(item)) {
      // result.push(item) // 这么写的话是把数组往另一个数组里面压(因为第一个参数是数组形式的，同时我们是遍历args 所以第一个元素不展开的话就是压数组而不是压数组元素) 会形成二维数组 而我们是需要追加到一维数组里面去
      result.push(...item)
    } else {
      result.push(item);
    }
  });
  // console.log(result);
  return result;
}

```

​	

# 17 slice数组切片

**08-数组合并与拆分.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数组合并与拆分</title>
    <script src="08-concat.js"></script>
  </head>
  <body>
    <script>
      // 数组切片
      let arr = [1, 3, 5, 7, 9, 15];
      // let result = arr.slice(1, 5); // slice是左闭右开
      // console.log(result);

      const result = slice(arr, 1, 5);
      // const result = slice(arr);
      console.log(result);
    </script>
  </body>
</html>

```

**08-concat.js**

```js
/**
 * 
 * @param {Array} arr 
 * @param {Number} begin 
 * @param {Number} end 
 * @returns 
 */
function slice(arr, begin, end) {
  // 若arr数组长度为 0
  if (arr.length === 0) {
    return [];
  }

  // 判断 begin
  begin = begin || 0; // 如果没有传参begin 则设置默认值0
  if (begin >= arr.length) {
    return [];
  }

  // 判断 end
  end = end || arr.length; // 如果没有传参end 则设置默认值数组长度
  if (end < begin) {
    end = arr.length;
  }

  // 声明一个空数组
  const result = [];

  // 遍历对象
  for (var i = 0; i < arr.length; i++) {
    if (i >= begin && i < end) {
      // 将下标对应的元素压入数组
      result.push(arr[i]);
    }
  }

  return result;
}

```

​	

# 18 数组扁平化-1

