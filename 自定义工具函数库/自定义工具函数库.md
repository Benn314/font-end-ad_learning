# 01 课程介绍

[自定义工具函数库 | 尚硅谷](https://zxfjd3g.github.io/atguigu_utils-docs/)

克隆对象涉及一个问题 深拷贝 课程会讲解四种深拷贝的方式

大厂面试喜欢一些底层的 原生JS 所以这门课程对面试是有帮助的

​	

# 02 call函数封装实现

可以改变函数运行时的this值 并且得到函数运行的执行结果

![image-20221026103416179](自定义工具函数库.assets/image-20221026103416179.png)

第一次打印的时候 obj的temp属性还没有被delete 所以可以看到temp属性被打印出来 执行完call函数后 temp属性被delete 所以就看不到了

**01-call.js**

```js
/**
 * 第一个参数 我们要执行的函数
 * 第二个参数 函数运行时this指向的对象
 * 第三个参数起 函数运行时的参数
 */
function call(Fn,obj,...args){
  // 判断
  if(obj === undefined || obj === null){
    obj = globalThis; //全局对象 globalThis es11的特性 用它来指向全局对象
  }
  // 为 obj 添加临时方法
  obj.temp = Fn;
  // 调用 temp 方法
  let result = obj.temp(...args);
  // 删除 temp 方法
  delete obj.temp;
  // 返回执行结果
  return result;
}
```

**01-call.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="01-call.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      return a + b + this.c
    }
    // 声明一个对象
    let obj = {
      c:521
    }
    // 添加全局属性
    window.c = 1314;

    // 执行 call 函数
    console.log(call(add,obj,10,20));
    // console.log(obj);
    console.log(call(add,null,10,20));
    // console.log(obj);

  </script>
</body>
</html>
```

​	

# 03 apply函数封装实现

也是改变函数运行时的this值 并且得到函数运行的执行结果

但apply函数和call函数还是有一个很明显的区别 区别在于函数运行时的一个参数 它的设定是一个数组 而call的实参是以单独形式存在的

**02-apply.js**

```js
// 这里就不用res参数了（... 表示多个参数吗？查一下） 直接用args普通参数就可以了
function apply(Fn, obj, args){ // 因为这里args只传一个数组参数 所以写一个args就行
  //判断
  if(obj === undefined || obj === null){ // 如果对象是未定义或为空
    obj = globalThis; //让对象等于全局对象（chrome里全局对象是window对象 IE里的全局对象是global对象）
  }
  // 为 obj 添加临时方法
  obj.temp = Fn;
  // 执行方法
  let result = obj.temp(...args); // ...是扩展运算符 要把它（数组）展开
  // 删除临时属性
  delete obj.temp;
  // 返回结果
  return result;
}
```

**02-apply.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>apply 测试</title>
  <script src="02-apply.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      return a + b + this.c
    }
    // 声明一个对象
    let obj = {
      c:521
    }
    // 添加全局属性
    window.c = 1314;

    // 执行 apply 函数
    console.log(apply(add,obj,[10, 20]));
    console.log(apply(add,null,[10, 20]));
  </script>
</body>
</html>
```

​	

# 04 bind函数封装实现

bind函数跟call函数很像 call会执行目标函数 bind会创建一个新函数 但是它不会去执行函数 这是bind和call的一个区别 至于参数这块他们是相同的

![image-20221026204406292](自定义工具函数库.assets/image-20221026204406292.png)

![image-20221026204851270](自定义工具函数库.assets/image-20221026204851270.png)

**03-bind.js**

```js
function bind(Fn, obj, ...args){
  // 返回一个新的函数
  return function(...args2){
    // 执行 call 函数
    return call(Fn, obj, ...args, ...args2); //这里的...args, ...args2不代表什么 就是实参传入的【位置以及调用】顺序而已
  }
}
```

**03-bind.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>bind函数</title>
  <script src="01-call.js"></script>
  <script src="03-bind.js"></script>
</head>
<body>
  <script>
    // 声明一个函数
    function add(a,b){
      console.log(this);
      console.log(arguments);
      return a + b + this.c;
    }
    //声明一个对象
    let obj = {
      c: 521
    };
    //添加全局属性
    window.c = 1314;

    //执行函数
    // let fn = bind(add, obj, 10, 20);
    // console.log(fn());

    // let fn2 = bind(add, obj);
    // console.log(fn2(10,20));

    let fn3 = add.bind(obj,10,20); //这里的bind不是我们自定义的 而是原型内置的
    console.log(fn3(30, 40));

    let fn4 = bind(add, obj, 10, 20);
    console.log(fn4(30, 40)); //后面的失效只是因为add只调用到了前面的两个实参 后面的没调用就没参与计算 可以通过arguments看到实参的数量和顺序位置
  </script>
</body>
</html>
```

​	

# 05 函数节流

